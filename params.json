{"name":"restful.io","tagline":"Restful-like routing module for NodeJS and socket.io","body":"restful.io\r\n==========\r\n\r\nrestful.io has been designed to develop quickly a realtime routing system for your \"RESTful-like\" apps. It's using [socket.io](https://github.com/Automattic/socket.io) but the module does not depend on it\r\n\r\nInspirations\r\n------------\r\n- [Play Framework 2](https://github.com/playframework/playframework)\r\n- [Express.io](https://github.com/techpines/express.io)\r\n- RESTful architectures\r\n\r\nInstallation\r\n------------\r\n`npm install --save restful.io`\r\n\r\nOverview\r\n-----\r\nBelow is a quick presentation of the module. You may check examples subdir for more.\r\n\r\n\r\n## Server-side\r\n\r\n```javascript\r\nvar http = require('http').Server();\r\nvar io = require(\"socket.io\")(http);\r\n\r\nvar RestfulRouter = require(\"restful.io\");\r\n\r\nvar FooController = {\r\n  // Because Node is asynchronous, is more convenient to use an async pattern, and not return directly a result.\r\n  // result is a callback (you can obviously change the name), you can omit it if your route does not return anything\r\n  bar: function(param, result) {\r\n    console.log(\"FooController.bar(\"+param+\");\");\r\n    result(\"OK\");\r\n  },\r\n  // Your route does not return anything, omit result callback\r\n  barJson: function(jsonParam) {\r\n    console.log(\"FooController.barJson(\"+JSON.stringify(jsonParam)+\");\");\r\n  }\r\n};\r\n\r\n// This ugly stuff is actually used to have a way to link route string and JS object\r\nvar ControllerScope = {\r\n  \"FooController\": FooController\r\n};\r\n\r\nvar router = new RestfulRouter(ControllerScope, {\r\n  // These are method names, feel free to change or to add\r\n  // Here I used GET/PUT/DELETE only to mimic classic RESTful app\r\n  GET: [\r\n    {\r\n      // p:varname indicates a primitive type parameter\r\n      // Parameter names are bound between uri and route handler\r\n      uri: \"/foo/p:param\",\r\n      to: \"FooController.bar(param)\"\r\n    },\r\n    // CAREFUL !! Route order matters.\r\n    // The following route will never get matched because 'useless' will be treated as 'param' for first route\r\n    {\r\n      uri: \"/foo/useless\",\r\n      to: \"FooController.neverCalled()\"\r\n    }\r\n    // You can add as many more routes as you wish\r\n  ],\r\n  PUT: [\r\n    {\r\n      // j:varname indicates a JSON object parameter\r\n      uri: \"/foo/j:param\",\r\n      to: \"FooController.barJson(param)\"\r\n    }\r\n  ],\r\n  POST: [\r\n    // No route yet\r\n  ],\r\n  DELETE: [\r\n    // No route yet\r\n  ],\r\n  // Nested methods are supported\r\n  FOO: {\r\n    BAR: [\r\n      // Here, the method will be FOO:BAR (: is the default separator)\r\n      // No route yet\r\n    ]\r\n  }\r\n}, true);\r\n\r\nrouter.start(io);\r\n\r\nhttp.listen(8080);\r\n```\r\n\r\n## Client-side\r\n\r\nYou have two ways to deal with the client side.\r\n\r\n### Client API\r\n\r\nThis is the preferred way. The second parameter of start method is a boolean. Set it to true on the server side as below :\r\n\r\n```javascript\r\nrouter.start(io, true);\r\n```\r\n\r\nNow on the client side, you can make a GET on /api to retrieve the code :\r\n\r\n\r\n```javascript\r\nvar socket = io('http://localhost:8080');\r\nsocket.on('connect', function() {\r\n  // Here we wait for API\r\n  socket.on('GET:RESULT', function(apiSrc) {\r\n    // You get JS code to eval\r\n    var API = eval(apiSrc)(socket);\r\n\r\n    // Get foo 1\r\n    API.GET(\"/foo/1\", {}, function(data) {\r\n      console.log(\"Result GET : \" + data);\r\n    });\r\n\r\n    API.PUT(\"/foo/j:user\", {\r\n      user: {\r\n        name: \"John Smith\",\r\n        age: 42\r\n      }\r\n    }, function(user) {\r\n      console.log(\"Result PUT : \" + user);\r\n    });\r\n  });\r\n\r\n  // Asking for API\r\n  socket.emit('GET', '/api');\r\n});\r\n```\r\n\r\nBy default, API's code is automagically generated using your routes. For nested methods, use subobjects :\r\n\r\n```javascript\r\nAPI.FOO.BAR; // Corresponds to nested method BAR inside FOO\r\n```\r\n\r\nPlease note that every autogenerated function in API has the same signature :\r\n\r\n```javascript\r\nAPI.YOUR_METHOD(uri, jsonParams, callback)\r\n```\r\n\r\n\r\n##### Extending API\r\n\r\nIf you need to expose to client more API methods than autogenerated ones, just provide an APIController inside router context and create a method inside with the following signature :\r\n\r\n```javascript\r\nfunction get(API) {\r\n  // Do your stuff and add your custom methods here\r\n  // Remember that API code is sent WITHOUT the context, so never use variables which doesn't live in API context.\r\n  return API;\r\n}\r\n```\r\n\r\n### Raw Javascript (with socket.io-client)\r\n\r\nThis method is dangerous. Because socket.io is asynchronous by nature, you can have several handlers listening on the same event.\r\n\r\nIn restful.io, each request is associated with a unique ID. If you use raw Javascript, you will have to handle these identifiers manually.\r\n\r\nRemember that if you don't provide any unique ID to socket.emit, other handlers listening for response might intercept your request's response too, potentially conflicting with yours, which may end on unpredictable behaviours.\r\n\r\n```javascript\r\nvar socket = io('http://localhost:8080');\r\nsocket.on('connect', function() {\r\n  // For primitive parameters, you can pass it directly in the URI\r\n  socket.emit('GET', '/foo/4');\r\n\r\n  socket.on('GET:RESULT', function(data) {\r\n    console.log(\"Result GET : \" + data);\r\n  });\r\n\r\n  // For complex JSON parameter, you have to send a plain JSON object corresponding the format below\r\n  // The name of your parameter is used to retrieve the value\r\n  socket.emit('PUT', {\r\n    // Here we provide a requestId\r\n    requestId: 'REQUEST_1'\r\n    uri: '/foo/j:user',\r\n    json: {\r\n      user: {\r\n        name: \"John Smith\",\r\n        age: 42\r\n      }\r\n    }\r\n  });\r\n\r\n  // We have to listen on PUT:requestId and not on PUT:RESULT\r\n  // Actually, RESULT is the default requestId\r\n  socket.on('PUT:REQUEST_1', function(data) {\r\n    console.log(\"Result PUT : \" + data);\r\n  });\r\n});\r\n```\r\n\r\n## And more\r\n\r\nHere is described the usable parameters when constructing a router :\r\n\r\n| Name | Type | Defaults | Example |\r\n| ---- | ---- | -------- | ------  |\r\n| ctx  | JSON | NA | { \"FooController\": FooController, \"BarController\": BarController } |\r\n| routes | JSON | NA | Main JSON config. See snippet before |\r\n| verbose | boolean | false | If true, much more log will appear |\r\n| methodSeparator | character | ':' | Used for nested methods. |\r\n| uriSeparator | character | '/' | Used to parse URIs. |\r\n| parameterPrefix | string | \"p:\" | Used to identify primitive parameter. |\r\n| jsonParameterPrefix | string | \"j:\" | Used to identify complex JSON parameter. |\r\n| resultSuffix | string | \"RESULT\" | Default requestId fired to client if requestId not provided (GET:RESULT, POST:RESULT, ...) |\r\n\r\nWhen you start the router, as a third parameter, you may use a callback to handle user connection :\r\n\r\n```javascript\r\nrouter.start(io, true, function(socket) {\r\n  console.log(\"User connected on : \" + socket);\r\n});\r\n```\r\n\r\nWarranty\r\n--------\r\nrestful.io is currently under heavy development. I'm building this project for myself and i try to make the code as clean as possible (which is far away from now :)). Feel free to submit a PR. Same for this README.\r\n\r\n#### Known limitations\r\n- Route parsing is poor and must be rewritten\r\n- Error handling is very approximative\r\n- socket.io only\r\n\r\n#### Currently working on\r\n- Known limitations\r\n- Better parameters model\r\n- File support\r\n- Get rid of the context object\r\n\r\n#### Ideas for later\r\n- Get rid of socket.io to use raw Websockets ?\r\n- Client module ?\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}