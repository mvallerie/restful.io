{"name":"restful.io","tagline":"Restful-like routing module for NodeJS and socket.io","body":"restful.io\r\n==========\r\n\r\nrestful.io has been designed to develop quickly a realtime routing system for your \"RESTful-like\" apps. It's using [socket.io](https://github.com/Automattic/socket.io) but the module does not depend on it\r\n\r\nInspirations\r\n------------\r\n- [Play Framework 2](https://github.com/playframework/playframework)\r\n- [Express.io](https://github.com/techpines/express.io)\r\n- RESTful architectures\r\n\r\nInstallation\r\n------------\r\n`npm install --save restful.io`\r\n\r\nOverview\r\n-----\r\nBelow is a quick presentation of the module. You may check examples subdir for more.\r\n\r\n\r\n## Server-side\r\n\r\n```javascript\r\nvar http = require('http').Server();\r\nvar io = require(\"socket.io\")(http);\r\n\r\nvar RestfulRouter = require(\"restful.io\");\r\n\r\nvar FooController = {\r\n  // each method of your controllers has to take the route as first parameter\r\n  bar: function(route, param) {\r\n    console.log(\"FooController.bar(\"+param+\");\");\r\n    // Here we route the request\r\n    route.OK(\"OK\");\r\n  },\r\n  // Your route does not return anything, omit result callback\r\n  barJson: function(route, jsonParam) {\r\n    console.log(\"FooController.barJson(\"+JSON.stringify(jsonParam)+\");\");\r\n    // You don't call any of the route's methods so no response\r\n  }\r\n};\r\n\r\n// This ugly stuff is actually used to have a way to link route string and JS object\r\nvar ControllerScope = {\r\n  \"FooController\": FooController\r\n};\r\n\r\nvar router = new RestfulRouter(ControllerScope, {\r\n  // These are method names, feel free to change or to add\r\n  // Here I used GET/PUT/DELETE only to mimic classic RESTful app\r\n  GET: [\r\n    {\r\n      // p:varname indicates a primitive type parameter\r\n      // Parameter names are bound between uri and route handler\r\n      uri: \"/foo/p:param\",\r\n      to: \"FooController.bar(param)\"\r\n    },\r\n    // CAREFUL !! Route order matters.\r\n    // The following route will never get matched because 'useless' will be treated as 'param' for first route\r\n    {\r\n      uri: \"/foo/useless\",\r\n      to: \"FooController.neverCalled()\"\r\n    }\r\n    // You can add as many more routes as you wish\r\n  ],\r\n  PUT: [\r\n    {\r\n      // j:varname indicates a JSON object parameter\r\n      // That means that the client have to send something which looks like => {user: {/* data */}}\r\n      uri: \"/foo\",\r\n      to: \"FooController.barJson(j:user)\"\r\n    }\r\n  ],\r\n  POST: [\r\n    // No route yet\r\n  ],\r\n  DELETE: [\r\n    // No route yet\r\n  ],\r\n  // Nested methods are supported\r\n  FOO: {\r\n    BAR: [\r\n      // Here, the method will be FOO:BAR (: is the default separator)\r\n      // No route yet\r\n    ]\r\n  }\r\n}, true);\r\n\r\nrouter.start(io);\r\n\r\nhttp.listen(8080);\r\n```\r\n\r\n### Route object methods and attrs\r\n\r\nBy convention, upper case identifiers end the route and send back something to client.\r\nLowercase identifiers does not end the route.\r\n\r\n| Name | Parameters | Effect | Example |\r\n| ---- | ---- | -------- | ------  |\r\n| OK  | data: * | Sends back data to the client with a 200 result | route.OK({message: \"done\"}) |\r\n| FORBIDDEN | err: String | Sends back data to the client with a 403 result | route.FORBIDDEN(\"Error !!\") |\r\n| follow | NA | If the route is not yet processed, \"follow\" sends the request to its routeHandler. This is useful with AuthHandlers | route.follow() |\r\n| token | NA | If you are authentified, you can access the token. | route.token |\r\n\r\n## Client-side\r\n\r\nYou have two ways to deal with the client side.\r\n\r\n### Client API\r\n\r\nThis is the preferred way. The second parameter of start method is a boolean. Set it to true on the server side as below :\r\n\r\n```javascript\r\nrouter.start(io, true);\r\n```\r\n\r\n#### Authentication note\r\n\r\nBy default, when client API is exposed, every request has to be authenticated.\r\nDefault authentication handler is bound on uri /api/login and is very permissive : no credentials needed.\r\n\r\nBut actually this boolean parameter can be set to any valid AuthHandler. A valid AuthHandler looks like a controller designed for authentication purposes :\r\n\r\n```javascript\r\nrouter.start(io, {\r\n  // Warning : Pseudocode below :)\r\n\r\n  handleRoutes: function(routes) -> nothing\r\n\r\n  handleRequest: function(route, data) -> nothing (you have to call one of the route methods)\r\n\r\n  login: function(route, data) -> nothing (you have to call one of the route methods)\r\n\r\n  logout: function(route) -> nothing (you have to call one of the route methods)\r\n});\r\n```\r\n\r\nIf you need to know more about that, please read auth/TokenAuthHandler.coffee\r\n\r\nIn case you need public API without any kind of authentication, just put a \"public\" attribute to true for each route you want to expose :\r\n\r\n```javascript\r\nroutes = {\r\n  GET: [\r\n    {\r\n      uri: \"/iam/public\",\r\n      to: \"IamController.public()\",\r\n      public: true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nNow on the client side, you can make a GET on /api to retrieve the code :\r\n\r\n\r\n```javascript\r\nvar socket = io('http://localhost:8080');\r\nsocket.on('connect', function() {\r\n  // Here we wait for API\r\n  socket.on('GET:RESULT', function(apiSrc) {\r\n    // You get JS code to eval\r\n    var API = eval(apiSrc)(socket);\r\n\r\n    // If you don't use authentication, skip this call\r\n    API.GET(\"/api/login\", {}, function(result) {\r\n      // You HAVE to do the following.\r\n      API.token = r.data;\r\n      // Now forget about the authentication.......\r\n\r\n      console.log(\"Now logged in\");\r\n      // Get foo 1\r\n      API.GET(\"/foo/1\", {}, function(result) {\r\n        console.log(\"Result GET : \" + JSON.stringify(result));\r\n\r\n        API.PUT(\"/foo\", {\r\n          user: {\r\n            name: \"John Smith\",\r\n            age: 42\r\n          }\r\n        }, function(result) {\r\n          console.log(\"Result PUT : \" + JSON.stringify(result));\r\n\r\n          // ...........until now :)\r\n          API.GET(\"/api/logout\", {}, function(result) {\r\n            console.log(\"Now logged off\");\r\n          });\r\n        });\r\n\r\n      });\r\n\r\n    });\r\n\r\n  });\r\n\r\n  // Asking for API\r\n  socket.emit('GET', '/api');\r\n});\r\n```\r\n\r\nBy default, API's code is automagically generated using your routes. For nested methods, use subobjects :\r\n\r\n```javascript\r\nAPI.FOO.BAR; // Corresponds to nested method BAR inside FOO\r\n```\r\n\r\nPlease note that every autogenerated function in API has the same signature :\r\n\r\n```javascript\r\nAPI.YOUR_METHOD(uri, jsonParams, callback)\r\n```\r\n\r\n\r\n##### Extending API\r\n\r\nIf you need to expose to client more API methods than autogenerated ones, just provide an APIController inside router context and create a method inside with the following signature :\r\n\r\n```javascript\r\nfunction get(API) {\r\n  // Do your stuff and add your custom methods here\r\n  // Note : this method is synchronous. No need for \"andThen\" callback. But don't forget to return valid API object !\r\n  // Remember that API code is sent WITHOUT the context, so never use variables which doesn't live in API context.\r\n  return API;\r\n}\r\n```\r\n\r\n\r\n### Raw Javascript (with socket.io-client)\r\n\r\nThis method is dangerous. Because socket.io is asynchronous by nature, you can have several handlers listening on the same event.\r\n\r\nIn restful.io, each request is associated with a unique ID. If you use raw Javascript, you will have to handle these identifiers manually.\r\n\r\nRemember that if you don't provide any unique ID to socket.emit, other handlers listening for response might intercept your request's response too, potentially conflicting with yours, which may end on unpredictable behaviours.\r\n\r\n```javascript\r\nvar socket = io('http://localhost:8080');\r\nsocket.on('connect', function() {\r\n  // For simple parameters, you can pass it directly in the URI\r\n  socket.emit('GET', '/foo/4');\r\n\r\n  socket.on('GET:RESULT', function(data) {\r\n    console.log(\"Result GET : \" + data);\r\n  });\r\n\r\n  // For complex parameters, you have to send a plain JSON object corresponding the format below\r\n  // The name of your parameter is used to retrieve the value\r\n  socket.emit('PUT', {\r\n    // Here we provide a requestId\r\n    requestId: 'REQUEST_1'\r\n    // If the request is authenticated, put this param too\r\n    token: 'foo',\r\n    uri: '/foo',\r\n    json: {\r\n      user: {\r\n        name: \"John Smith\",\r\n        age: 42\r\n      }\r\n    }\r\n  });\r\n\r\n  // We have to listen on PUT:requestId and not on PUT:RESULT\r\n  // Actually, RESULT is the default requestId\r\n  socket.on('PUT:REQUEST_1', function(data) {\r\n    console.log(\"Result PUT : \" + data);\r\n  });\r\n});\r\n```\r\n\r\n## And more\r\n\r\nHere is described the usable parameters when constructing a router :\r\n\r\n| Name | Type | Defaults | Example |\r\n| ---- | ---- | -------- | ------  |\r\n| ctx  | JSON Object | NA | { \"FooController\": FooController, \"BarController\": BarController } |\r\n| routes | JSON Object | NA | Main JSON config. See snippet before |\r\n| verbose | boolean | false | If true, much more log will appear |\r\n| methodSeparator | character | ':' | Used for nested methods. |\r\n| uriSeparator | character | '/' | Used to parse URIs. |\r\n| parameterPrefix | string | \"p:\" | Used to identify primitive parameter in route URI. |\r\n| jsonParameterPrefix | string | \"j:\" | Used to identify complex JSON parameter in route handler call. |\r\n| resultSuffix | string | \"RESULT\" | Default requestId fired to client if requestId not provided (GET:RESULT, POST:RESULT, ...) |\r\n\r\nWhen you start the router, as a third parameter, you may use a callback to handle user connection :\r\n\r\n```javascript\r\nrouter.start(io, true, function(socket) {\r\n  console.log(\"User connected on : \" + socket);\r\n});\r\n```\r\n\r\nWarranty\r\n--------\r\nrestful.io is currently under heavy development. I'm building this project for myself and i try to make the code as clean as possible (which is far away from now :)). Feel free to submit a PR. Same for this README.\r\n\r\n#### Known limitations\r\n- Route parsing is poor and must be rewritten\r\n- Error handling is very approximative\r\n- socket.io only\r\n\r\n#### Currently working on\r\n- Better authentication support\r\n- Known limitations\r\n- File support\r\n- Get rid of the context object\r\n\r\n#### Ideas for later\r\n- Get rid of socket.io to use raw Websockets ?\r\n- Client module ?\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}